#!/usr/bin/env node

var fs = require('fs')
var prompt = require('prompt-sync')()
var ethWallet = require('ethereumjs-wallet')
var ethICAP = require('ethereumjs-icap')
var ethUtil = require('ethereumjs-util')
var ethTx = require('ethereumjs-tx')
var RLP = require('rlp')

var yargs = require('yargs')
  .usage('Usage: $0 [command]')
  .option('p', {
    alias: 'private',
    describe: 'Private key as a hex string',
    type: 'string'
  })
  .option('password', {
    describe: 'Password for the private key',
    type: 'string'
  })
  .option('password-prompt', {
    describe: 'Prompt for the private key password',
    type: 'boolean'
  })
  .option('k', {
    alias: 'keyfile',
    describe: 'Encoded key file',
    type: 'string',
    normalize: true
  })
  .option('show-private', {
    describe: 'Show private key details',
    type: 'boolean'
  })
  .global([ 'p', 'k', 'password', 'password-prompt', 'show-private' ])
  .command('signMessage <message>', 'Sign a message')
  .command('createTx <nonce> <to> <value> <data> <gasLimit> <gasPrice>', 'Sign a transaction')
  .command('keyGenerate [format]', 'Generate new key')
  .command('keyConvert', 'Convert a key to V3 keystore format')
  .command('keyDetails', 'Print key details')
  .command('addressDetails <address>', 'Print details about an address')
  .command('rlpInspect <rlp>', 'Inspect RLP encoded data')
  .strict()
  .version()
  .showHelpOnFail(false, 'Specify --help for available options')
  .help()
  .demand(1, 'Must provide a command')

var argv = yargs.argv
var command = argv._[0]

function abort (msg) {
  console.log(msg || 'Error occured')
  process.exit(1)
}

function ensurePrivateKey () {
  if (!argv.p && !argv.k) {
    abort('A private key is mandatory for this operation')
  }
}

function askPassword () {
  return prompt('Password: ', { echo: '*' })
}

function ensurePassword () {
  if (argv.password) {
    return argv.password
  } else if (argv.passwordPrompt) {
    var password = askPassword()
    if (!password) {
      abort('A password is mandatory for this operation')
    } else {
      return password
    }
  } else {
    abort('A password is mandatory for this operation')
  }
}

function loadWallet () {
  ensurePrivateKey()

  var wallet
  if (argv.private) {
    wallet = ethWallet.fromPrivateKey(ethUtil.toBuffer(argv.private))
  } else if (argv.keyfile) {
    var keyfile = fs.readFileSync(argv.keyfile).toString()
    var password = ensurePassword()
    wallet = ethWallet.fromV3(keyfile, password, true)
  }

  return wallet
}

function printAddressDetails (address) {
  console.log('Address: ' + address)
  console.log('Address (checksum): ' + ethUtil.toChecksumAddress(address))
  console.log('ICAP: ' + ethICAP.fromAddress(address, true, true))
}

function printWalletDetails (wallet, showPrivate) {
  printAddressDetails(wallet.getAddressString())
  console.log('Public key: ' + wallet.getPublicKeyString())
  if (argv.showPrivate || showPrivate) {
    console.log('Private key: ' + wallet.getPrivateKeyString())
  }
}

function saveWalletV3 (wallet) {
  var password = ensurePassword()
  var v3 = wallet.toV3String(password)
  var filename = wallet.getV3Filename()

  fs.writeFileSync(filename, new Buffer(v3))
  console.log('Key saved as ' + filename)
}

var wallet

switch (command) {
  case 'keyGenerate':
    wallet = ethWallet.generate()

    switch (argv.format) {
      case 'v3':
        printWalletDetails(wallet)
        saveWalletV3(wallet)
        break

      case 'raw':
      default:
        printWalletDetails(wallet, true)
        break
    }
    break

  case 'keyDetails':
    wallet = loadWallet()

    printWalletDetails(wallet)
    break

  case 'keyConvert':
    wallet = loadWallet()

    saveWalletV3(wallet)
    break

  case 'signMessage':
    wallet = loadWallet()

    // NOTE: geth internally accepts any input and zero-pads it
    var msg = ethUtil.sha3(ethUtil.toBuffer(argv.message))
    console.log('Input message: ' + argv.message)
    console.log('Message hash (Keccak): ' + ethUtil.bufferToHex(msg))

    var sig = ethUtil.ecsign(msg, wallet.getPrivateKey())

    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
    sig = ethUtil.bufferToHex(Buffer.concat([ sig.r, sig.s, ethUtil.toBuffer(sig.v - 27) ]))

    console.log('The signature: ' + sig)
    break

  case 'createTx':
    function shadyparser (input) {
      return ethUtil.bufferToHex(ethUtil.toBuffer(input))
    }

    // FIXME: validate inputs
    var nonce = shadyparser(argv.nonce)
    var to = shadyparser(argv.to)
    var value = shadyparser(argv.value)
    var data = shadyparser(argv.data)
    var gasLimit = shadyparser(argv.gasLimit)
    var gasPrice = shadyparser(argv.gasPrice)

    console.log('Nonce: ' + nonce)
    console.log('To: ' + to)
    console.log('Value: ' + value)
    console.log('Data: ' + data)
    console.log('Gas limit: ' + gasLimit)
    console.log('Gas price: ' + gasPrice)

    /* eslint-disable new-cap */
    var tx = new ethTx({
      nonce: nonce,
      to: to,
      value: value,
      data: data,
      gasLimit: gasLimit,
      gasPrice: gasPrice
    })
    /* eslint-enable new-cap */

    wallet = loadWallet()
    tx.sign(wallet.getPrivateKey())

    console.log('The signed transaction: ' + ethUtil.bufferToHex(tx.serialize()))
    break

  case 'addressDetails':
    var address = argv.address
    if (ethICAP.isICAP(address)) {
      try {
        address = ethICAP.toAddress(address)
      } catch (e) {
        abort('The address supplied is an Indirect ICAP')
      }
    } else if (!/^0?x?[0-9a-fA-F]{40}$/i.test(address)) {
      abort('Invalid address')
    } else {
      address = address.toLowerCase()

      if ((address !== argv.address) && !ethUtil.isValidChecksumAddress(argv.address)) {
        console.warn('The supplied address failed the checksum test. It might be invalid.')
      }
    }

    printAddressDetails(address)
    break

  case 'rlpInspect':
    function toReadable (val) {
      var len = val.length

      if (len === 20) {
        return 'possibly an address'
      }

      if (len <= 32) {
        return new ethUtil.BN(val).toString(10)
      }
    }

    var rlp = RLP.decode(argv.rlp)

    console.log('The RLP encoded input consists of the following fields:')
    for (var i = 0; i < rlp.length; i++) {
      var item = rlp[i]
      var detail = toReadable(item)
      if (detail) {
        console.log('  ' + ethUtil.bufferToHex(item) + ' (' + detail + ')')
      } else {
        console.log('  ' + ethUtil.bufferToHex(item))
      }
    }
    break
}
